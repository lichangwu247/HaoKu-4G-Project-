
#include "rsa_crypt.h"
#include "sys.h"

uint8_t preallocated_buffer[4096]; /* buffer required for internal allocation of memory */

/******************************************************************************/
/***************************** RSA 1024 Vector  *******************************/
/******************************************************************************/
/***************称心公钥**********************/
const uint8_t CXModulus[] =
  {	
		0x76,0xF8,0xF9,0x72,0x95,0xF9,0x35,0xF7,0x5E,0xAA,0x82,0x0B,0xAA,0xB6,0xA2,0xCC,
		0xD5,0xAD,0x8F,0xD2,0xE5,0x94,0xFB,0x0E,0x67,0x7B,0xD8,0x04,0xA9,0xA4,0xCE,0x15,
		0x6E,0xE3,0x11,0x3F,0x56,0x39,0xA5,0xE8,0x88,0x1C,0x3C,0xA4,0x34,0x82,0x4C,0x65,
		0x34,0x30,0xC4,0xE1,0xEB,0x33,0xF0,0xB8,0xF9,0xD4,0xE5,0x73,0x02,0x2B,0xF1,0x76,
		0xC9,0x1D,0xEB,0x87,0xAD,0xB2,0x7D,0x4B,0x9A,0xBA,0x9F,0xA6,0x9C,0x6B,0x75,0x1A,
		0x04,0x00,0x83,0x0C,0x23,0xD6,0xF2,0xB8,0x38,0x9F,0x08,0xA6,0x2C,0x9E,0x33,0x57,
		0x34,0xFE,0xCA,0x4C,0xD6,0x0E,0x76,0x6E,0x55,0x18,0xAA,0xBE,0x5D,0xDE,0x9E,0xB2,
		0x87,0xC6,0x5B,0xF9,0x46,0x60,0xF8,0xC3,0x88,0x47,0xBD,0xA0,0x5A,0x03,0x39,0xC9
  };
	
const uint8_t CXPublicExponent[] =
  {
    0x01, 0x00, 0x01
  };
/*************END*****************/

const uint8_t Modulus[] =
  {	
	0xE5, 0x37, 0x6A, 0xC7, 0x6D, 0x1D, 0xAC, 0xA5, 0xBB, 0x80, 0x37, 0x5A, 0x5D, 0x7E, 0xCD, 0x04, 0x3A, 0xE7, 0xAA, 
	0xE6, 0x76, 0xF5, 0xB4, 0x38, 0x0B, 0x7D, 0xF0, 0xD5, 0xBF, 0x48, 0x7B, 0xD9, 0x9B, 0x83, 0x95, 0x9E, 0xF6, 0xD5, 
	0x02, 0x08, 0x3E, 0xE2, 0xC1, 0xDD, 0xF9, 0x4F, 0x74, 0xBB, 0x3D, 0x17, 0xFA, 0x9D, 0x0B, 0xD0, 0x45, 0x2F, 0x29, 
	0xA9, 0xE5, 0x6E, 0x6C, 0x17, 0x38, 0xDC, 0x71, 0xF2, 0x7A, 0x53, 0x06, 0x76, 0x86, 0xF9, 0x89, 0xB0, 0x2D, 0x4B, 
	0x6C, 0xFF, 0x65, 0xB9, 0xD7, 0x1D, 0x0F, 0x7A, 0x08, 0x14, 0x63, 0x43, 0xF5, 0x2C, 0xEB, 0x7A, 0xAD, 0x59, 0xC1, 
	0xB4, 0x36, 0x3D, 0xDE, 0x2A, 0x15, 0x52, 0x62, 0x35, 0x81, 0x08, 0xE7, 0x92, 0x55, 0xE2, 0xE5, 0x5D, 0x34, 0x6B, 
	0x9C, 0x0F, 0xB8, 0xE8, 0xC4, 0x11, 0x80, 0xC4, 0xE9, 0xBD, 0xA9, 0xA2, 0x66, 0xB1	
  };
	
const uint8_t PublicExponent[] =
  {
    0x01, 0x00, 0x01
  };

const uint8_t PrivateExponent[] =
  {
	0x31, 0x41, 0x9F, 0xA3, 0x53, 0xD6, 0x2E, 0xE1, 0xDD, 0x81, 0x4F, 0xC3, 0xCE, 0x38, 0x1F, 0xAF, 0xE3, 0x45, 0xA1,
	0xE2, 0xCD, 0x18, 0xFF, 0x3D, 0x94, 0xF0, 0x9F, 0x26, 0x9B, 0xA8, 0xA4, 0x9E, 0xAE, 0x4D, 0xD0, 0x42, 0xFD, 0x09,
	0x68, 0x9A, 0xA3, 0x82, 0xE0, 0x84, 0xC6, 0x1C, 0xB6, 0x39, 0xBF, 0x46, 0xEE, 0x1E, 0xBD, 0xE9, 0x67, 0x58, 0x9B,
	0x74, 0x2C, 0x3E, 0xB6, 0xA1, 0x25, 0xE1, 0x47, 0x3C, 0x0F, 0x54, 0x0E, 0x5A, 0x72, 0x48, 0x53, 0xD9, 0x20, 0x8E,
	0x7B, 0x83, 0x2D, 0xBB, 0x66, 0x14, 0x4D, 0x4D, 0x77, 0x82, 0xFA, 0x24, 0x17, 0x7C, 0xD0, 0x71, 0x5D, 0xAA, 0x71,
	0xDC, 0xFF, 0xCE, 0xD6, 0x29, 0x6B, 0xED, 0x1F, 0xF1, 0x42, 0x0E, 0xD6, 0xA9, 0xA5, 0x8A, 0x0C, 0x48, 0x0E, 0x44,
	0x62, 0xA2, 0x33, 0x80, 0x1D, 0xB0, 0x34, 0xA5, 0x13, 0x9C, 0xA2, 0xCE, 0xA0, 0x4D
  };

/* String of entropy */
uint8_t entropy_data[32] =
  {
    0x91, 0x20, 0x1a, 0x18, 0x9b, 0x6d, 0x1a, 0xa7,
    0x0e, 0x69, 0x57, 0x6f, 0x36, 0xb6, 0xaa, 0x88,
    0x55, 0xfd, 0x4a, 0x7f, 0x97, 0xe9, 0x72, 0x69,
    0xb6, 0x60, 0x88, 0x78, 0xe1, 0x9c, 0x8c, 0xa5
  };

//使用称心公钥加密数据进行传输
int32_t RSA_Encryption(uint8_t* msg, uint8_t msg_size, uint8_t* Encrypted)
{
	int32_t status = RSA_ERR_GENERIC;
  RSApubKey_stt PubKey_st;
	/******************************/

  /* Preparing for Encryption */
  PubKey_st.mExponentSize = sizeof(CXPublicExponent);
  PubKey_st.mModulusSize = sizeof(CXModulus);
  PubKey_st.pmExponent = (uint8_t *) CXPublicExponent;
  PubKey_st.pmModulus = (uint8_t *)CXModulus;
	
	COM_DBG("Encrypt message: ");
//  DBG_HEX( (unsigned char*)msg, msg_size);
	COM_DBG("\r\n");
	
  status = RSA_Encrypt(&PubKey_st, msg, msg_size, Encrypted);
	
	COM_DBG("status: %d\r\n",status);
	if (status == RSA_SUCCESS)
  {
		COM_DBG("Encrypted cryptogram: ");
		DBG_HEX((unsigned char*)Encrypted, sizeof(Encrypted));
		DBG_HEX((unsigned char*)Encrypted, RSA_BIT/8);
		COM_DBG("\r\n");		
	}
  return status;				
}										



int32_t  RSA_Decryption(uint8_t* in_output, int32_t* output_size)
{
	int32_t status = RSA_ERR_GENERIC;
  RSAprivKey_stt PrivKey_st;
	/******************************/

	/* Now we will test decryption */
    PrivKey_st.mExponentSize = sizeof(PrivateExponent);
    PrivKey_st.mModulusSize = sizeof(Modulus);
    PrivKey_st.pmExponent = (uint8_t *) PrivateExponent;
    PrivKey_st.pmModulus = (uint8_t *) Modulus;
    status = RSA_Decrypt(&PrivKey_st, in_output, in_output, output_size);
		
		COM_DBG("status: %d\r\n",status);

    if (status == RSA_SUCCESS)
    {
				COM_DBG("Decrypt message: ");
        DBG_HEX( (unsigned char*)in_output, *output_size);
	      COM_DBG("\r\n");
    }
  return status;		
}

/**
  * @brief  RSA Encryption with PKCS#1v1.5
  * @param  P_pPubKey The RSA public key structure, already initialized
  * @param  P_pInputMessage Input Message to be signed
  * @param  P_MessageSize Size of input message
  * @param  P_pOutput Pointer to output buffer
  * @retval error status: can be RSA_SUCCESS if success or one of
  * RSA_ERR_BAD_PARAMETER, RSA_ERR_MESSAGE_TOO_LONG, RSA_ERR_BAD_OPERATION
*/
int32_t RSA_Encrypt(RSApubKey_stt *P_pPubKey,
                    const uint8_t *P_pInputMessage,
                    int32_t P_InputSize,
                    uint8_t *P_pOutput)
{
  int32_t status = RNG_SUCCESS ;
  RNGstate_stt RNGstate;
  RNGinitInput_stt RNGinit_st;
  RNGinit_st.pmEntropyData = entropy_data;
  RNGinit_st.mEntropyDataSize = sizeof(entropy_data);
  RNGinit_st.mPersDataSize = 0;
  RNGinit_st.mNonceSize = 0;

  status = RNGinit(&RNGinit_st, &RNGstate);
  if (status == RNG_SUCCESS)
  {
    RSAinOut_stt inOut_st;
    membuf_stt mb;

    mb.mSize = sizeof(preallocated_buffer);
    mb.mUsed = 0;
    mb.pmBuf = preallocated_buffer;

    /* Fill the RSAinOut_stt */
    inOut_st.pmInput = P_pInputMessage;
    inOut_st.mInputSize = P_InputSize;
    inOut_st.pmOutput = P_pOutput;

    /* Encrypt the message, this function will write sizeof(modulus) data */
    status = RSA_PKCS1v15_Encrypt(P_pPubKey, &inOut_st, &RNGstate, &mb);
  }
  return(status);
}

/**
  * @brief  RSA Decryption with PKCS#1v1.5
  * @param  P_pPrivKey The RSA private key structure, already initialized
  * @param  P_pInputMessage Input Message to be signed
  * @param  P_MessageSize Size of input message
  * @param  P_pOutput Pointer to output buffer
  * @retval error status: can be RSA_SUCCESS if success or RSA_ERR_GENERIC in case of fail
*/ 
int32_t RSA_Decrypt(RSAprivKey_stt * P_pPrivKey,
                    const uint8_t * P_pInputMessage,
                    uint8_t *P_pOutput,
                    int32_t *P_OutputSize)
{
  int32_t status = RSA_SUCCESS ;
  RSAinOut_stt inOut_st;
  membuf_stt mb;

  mb.mSize = sizeof(preallocated_buffer);
  mb.mUsed = 0;
  mb.pmBuf = preallocated_buffer;

  /* Fill the RSAinOut_stt */
  inOut_st.pmInput = P_pInputMessage;
  inOut_st.mInputSize = P_pPrivKey->mModulusSize;
  inOut_st.pmOutput = P_pOutput;

  /* Encrypt the message, this function will write sizeof(modulus) data */
  status = RSA_PKCS1v15_Decrypt(P_pPrivKey, &inOut_st, P_OutputSize, &mb);
  return(status);
}

/***********************************************************/

